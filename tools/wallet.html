<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Wallet Tools</title>
    <meta name="description" content="Solana Wallet Tools" />
    <meta name="author" content="Dev Twenty Seven" />
    <link rel="icon" href="../assets/icons/27-icon.png" type="image/png">

    <meta property="og:title" content="Solana Wallet Tools" />
    <meta property="og:description" content="Solana Wallet Tools" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="../assets/icons/27-icon.png" />
    <style>
        body { font-family: sans-serif; background:#111; color:#eee; padding:20px;}
        input, button { margin:5px; padding:8px; font-size:14px; border-radius:5px;}
        button { cursor:pointer; background:#512da8; color:white; border:none;}
        button:disabled { background:#444; cursor:not-allowed;}
        a { color:#4fc3f7; text-decoration:none;}
        #status { word-wrap: break-word; }
    </style>
</head>

<body>

<h1>Solana Mainnet Dashboard</h1>

<button id="connectBtn">üîó Conectar Wallet</button>
<button id="disconnectBtn" disabled>‚ùå Desconectar Wallet</button>
<button id="refreshBtn" disabled>üîÑ Atualizar</button>
<p id="walletAddress">Wallet: n√£o conectada</p>

<h3>Saldo:</h3>
<p id="balance">-</p>

<h3>Enviar SOL:</h3>
<label>Destino:</label>
<input type="text" id="destInput" placeholder="Endere√ßo base58" size="60">
<label>Valor (SOL):</label>
<input type="number" id="amountInput" value="0.001" step="0.0001" min="0.0001">
<br>
<button id="sendBtn" disabled>üí∏ Enviar</button>

<h3>√öltimas Transa√ß√µes:</h3>
<ul id="txHistory"></ul>

<p id="status"></p>

<script type="module">
import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "https://esm.sh/@solana/web3.js@1.95.3";

let provider = null;
let pubKey = null;
let connection = null;
let currentRpcIndex = 0;
const RPC_ENDPOINTS = [
  "https://rpc.ankr.com/solana",
  "https://solana-mainnet.core.chainstack.com/693b6b3f0a0aead3d53a0104e9f2f7d8",
  "https://api.mainnet-beta.solana.com"
];

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const refreshBtn = document.getElementById("refreshBtn");
const walletAddress = document.getElementById("walletAddress");
const balanceEl = document.getElementById("balance");
const statusEl = document.getElementById("status");
const destInput = document.getElementById("destInput");
const amountInput = document.getElementById("amountInput");
const txHistory = document.getElementById("txHistory");

// Fun√ß√£o para esperar
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Conectar RPC com fallback
async function updateConnection() {
  for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
    try {
      connection = new Connection(RPC_ENDPOINTS[currentRpcIndex], "confirmed");
      console.log(`Conectado ao RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
      statusEl.textContent = `üîó Conectado ao RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`;
      return true;
    } catch (err) {
      console.error(`Falha ao conectar ao RPC ${RPC_ENDPOINTS[currentRpcIndex]}:`, err);
      currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
    }
  }
  statusEl.textContent = "‚ùå Falha ao conectar a todos os RPCs. Verifique sua rede ou configure um RPC pr√≥prio.";
  return false;
}

// Detecta Phantom
const getProvider = () => {
  if ("solana" in window) {
    const provider = window.solana;
    if (provider.isPhantom) return provider;
  }
  alert("Phantom n√£o encontrada! Instale a extens√£o em https://phantom.app.");
  return null;
};

// Atualiza saldo com retry
async function updateBalance(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    balanceEl.textContent = "Wallet ou conex√£o n√£o dispon√≠vel.";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const lamports = await connection.getBalance(pubKey);
      balanceEl.textContent = `${(lamports / LAMPORTS_PER_SOL).toFixed(4)} SOL (Mainnet Beta)`;
      return;
    } catch (err) {
      console.error(`Tentativa ${i + 1} - Erro ao buscar saldo:`, err);
      if ((err.message.includes("Failed to fetch") || err.message.includes("403")) && i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      balanceEl.textContent = `Erro ao buscar saldo: ${err.message}. Tente novamente.`;
      return;
    }
  }
}

// Carregar hist√≥rico de transa√ß√µes com retry
async function loadTransactionHistory(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    txHistory.innerHTML = "<li>Wallet ou conex√£o n√£o dispon√≠vel.</li>";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const signatures = await connection.getSignaturesForAddress(pubKey, { limit: 10 });
      txHistory.innerHTML = "";
      if (signatures.length === 0) {
        txHistory.innerHTML = "<li>Sem transa√ß√µes recentes.</li>";
        return;
      }
      for (const sigInfo of signatures) {
        const li = document.createElement("li");
        li.innerHTML = `<a href="https://explorer.solana.com/tx/${sigInfo.signature}?cluster=mainnet-beta" target="_blank">${sigInfo.signature.slice(0, 8)}...</a>`;
        txHistory.appendChild(li);
      }
      return;
    } catch (err) {
      console.error(`Tentativa ${i + 1} - Erro ao carregar hist√≥rico:`, err);
      if ((err.message.includes("Failed to fetch") || err.message.includes("403")) && i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      txHistory.innerHTML = `<li>Hist√≥rico indispon√≠vel: ${err.message}. Tente novamente.</li>`;
      return;
    }
  }
}

// Atualiza√ß√£o autom√°tica
let intervalId = null;
function startAutoUpdate() {
  if (intervalId) clearInterval(intervalId);
  intervalId = setInterval(async () => {
    if (pubKey && connection) {
      await updateBalance();
      await loadTransactionHistory();
    }
  }, 60000); // 60s para evitar rate limits
}

function stopAutoUpdate() {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
  }
}

// Conectar Wallet
connectBtn.addEventListener("click", async () => {
  provider = getProvider();
  if (!provider) return;

  try {
    const resp = await provider.connect();
    pubKey = new PublicKey(resp.publicKey.toString());
    walletAddress.textContent = `Wallet: ${pubKey.toBase58()}`;
    disconnectBtn.disabled = false;
    sendBtn.disabled = false;
    refreshBtn.disabled = false;

    if (!await updateConnection()) return;
    await updateBalance();
    await loadTransactionHistory();
    startAutoUpdate();

    statusEl.textContent = "‚úÖ Conectado √† Mainnet Beta!";
  } catch (err) {
    console.error("Erro ao conectar:", err);
    statusEl.textContent = `‚ùå Erro ao conectar: ${err.message}`;
  }
});

// Desconectar Wallet
disconnectBtn.addEventListener("click", async () => {
  if (!provider) return;
  try {
    await provider.disconnect();
    pubKey = null;
    walletAddress.textContent = "Wallet: n√£o conectada";
    balanceEl.textContent = "-";
    statusEl.textContent = "‚ö†Ô∏è Wallet desconectada";
    txHistory.innerHTML = "";
    sendBtn.disabled = true;
    disconnectBtn.disabled = true;
    refreshBtn.disabled = true;
    stopAutoUpdate();
  } catch (err) {
    console.error("Erro ao desconectar:", err);
    statusEl.textContent = `‚ùå Erro ao desconectar: ${err.message}`;
  }
});

// Manual Refresh
refreshBtn.addEventListener("click", async () => {
  statusEl.textContent = "üîÑ Atualizando...";
  await updateBalance();
  await loadTransactionHistory();
  statusEl.textContent = pubKey ? "‚úÖ Atualiza√ß√£o conclu√≠da!" : "‚ö†Ô∏è Conecte a carteira primeiro.";
});

// Detecta desconex√£o direta no Phantom
window.addEventListener("load", () => {
  provider = getProvider();
  if (provider) {
    provider.on("disconnect", () => {
      pubKey = null;
      walletAddress.textContent = "Wallet: n√£o conectada";
      balanceEl.textContent = "-";
      statusEl.textContent = "‚ö†Ô∏è Wallet desconectada";
      txHistory.innerHTML = "";
      sendBtn.disabled = true;
      disconnectBtn.disabled = true;
      refreshBtn.disabled = true;
      stopAutoUpdate();
    });
    if (provider.isConnected) {
      provider.connect().catch(() => {});
    }
  }
});

// Enviar SOL
sendBtn.addEventListener("click", async () => {
  if (!provider || !pubKey || !connection) {
    alert("Conecte a carteira e verifique a conex√£o RPC!");
    return;
  }
  const destValue = destInput.value.trim();
  const amountValue = parseFloat(amountInput.value);

  if (!destValue || !amountValue || amountValue <= 0) {
    alert("Endere√ßo ou valor inv√°lido.");
    return;
  }

  try {
    const toPubkey = new PublicKey(destValue);
    const lamports = Math.floor(amountValue * LAMPORTS_PER_SOL);

    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: pubKey,
        toPubkey: toPubkey,
        lamports: lamports
      })
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = pubKey;

    const { signature } = await provider.signAndSendTransaction(transaction);
    await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });

    statusEl.innerHTML = `‚úÖ Enviado! Tx: <a href="https://explorer.solana.com/tx/${signature}?cluster=mainnet-beta" target="_blank">${signature.slice(0, 8)}...</a>`;

    await updateBalance();
    await loadTransactionHistory();
  } catch (err) {
    console.error("Erro ao enviar:", err);
    statusEl.textContent = `‚ùå Erro ao enviar: ${err.message}`;
  }
});
</script>
</body>
</html>
