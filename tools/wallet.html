<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Wallet Tools</title>
    <meta name="description" content="Solana Wallet Tools" />
    <meta name="author" content="Dev Twenty Seven" />
    <link rel="icon" href="/assets/icons/27-mini-icon.png" type="image/png">

    <meta property="og:title" content="Solana Wallet Tools" />
    <meta property="og:description" content="Solana Wallet Tools" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/assets/icons/27-mini-icon.png" />
    <style>
        body { font-family: sans-serif; background:#111; color:#eee; padding:20px;}
        input, button { margin:5px; padding:8px; font-size:14px; border-radius:5px;}
        button { cursor:pointer; background:#512da8; color:white; border:none;}
        button:disabled { background:#444; cursor:not-allowed;}
        a { color:#4fc3f7; text-decoration:none;}
        #status { word-wrap: break-word; }
    </style>
</head>

<body>

<h1>Solana Mainnet Dashboard</h1>

<button id="connectBtn">üîó Connect Wallet</button>
<button id="disconnectBtn" disabled>‚ùå Disconnect Wallet</button>
<button id="refreshBtn" disabled>üîÑ Refresh</button>
<p id="walletAddress">Wallet: not connected</p>

<h3>Balance:</h3>
<p id="balance">-</p>

<h3>Send SOL:</h3>
<label>Destination:</label>
<input type="text" id="destInput" placeholder="Base58 Address" size="60">
<label>Amount (SOL):</label>
<input type="number" id="amountInput" value="0.001" step="0.0001" min="0.0001">
<br>
<button id="sendBtn" disabled>üí∏ Send</button>

<h3>Recent Transactions:</h3>
<ul id="txHistory"></ul>

<p id="status">‚ÑπÔ∏è Connect your Phantom wallet to get started. For better performance, configure your own RPC at QuickNode or Ankr.</p>

<script type="module">
import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "https://esm.sh/@solana/web3.js@1.95.3";

let provider = null;
let pubKey = null;
let connection = null;
let currentRpcIndex = 0;
const RPC_ENDPOINTS = [
  "https://rpc.ankr.com/solana",
  "https://solana-rpc.publicnode.com",
  "https://api.mainnet-beta.solana.com"
];

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const refreshBtn = document.getElementById("refreshBtn");
const walletAddress = document.getElementById("walletAddress");
const balanceEl = document.getElementById("balance");
const statusEl = document.getElementById("status");
const destInput = document.getElementById("destInput");
const amountInput = document.getElementById("amountInput");
const txHistory = document.getElementById("txHistory");

// Sleep function
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Connect to RPC with fallback
async function updateConnection() {
  for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
    try {
      connection = new Connection(RPC_ENDPOINTS[currentRpcIndex], "confirmed");
      console.log(`Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
      statusEl.textContent = `üîó Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`;
      return true;
    } catch (err) {
      console.error(`Failed to connect to RPC ${RPC_ENDPOINTS[currentRpcIndex]}:`, err);
      currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
    }
  }
  statusEl.textContent = "‚ùå Failed to connect to all RPCs. Configure your own RPC at https://www.quicknode.com or https://www.ankr.com.";
  return false;
}

// Detect Phantom wallet
const getProvider = () => {
  if ("solana" in window) {
    const provider = window.solana;
    if (provider.isPhantom) return provider;
  }
  alert("Phantom not found! Install the extension at https://phantom.app.");
  return null;
};

// Update balance with retry
async function updateBalance(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    balanceEl.textContent = "Wallet or connection not available.";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const lamports = await connection.getBalance(pubKey);
      balanceEl.textContent = `${(lamports / LAMPORTS_PER_SOL).toFixed(4)} SOL (Mainnet Beta)`;
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error fetching balance:`, err);
      if ((err.message.includes("Failed to fetch") || err.message.includes("401") || err.message.includes("403")) && i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      balanceEl.textContent = `Error fetching balance: ${err.message}. Configure your own RPC at https://www.quicknode.com.`;
      return;
    }
  }
}

// Load transaction history with retry
async function loadTransactionHistory(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    txHistory.innerHTML = "<li>Wallet or connection not available.</li>";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const signatures = await connection.getSignaturesForAddress(pubKey, { limit: 10 });
      txHistory.innerHTML = "";
      if (signatures.length === 0) {
        txHistory.innerHTML = "<li>No recent transactions.</li>";
        return;
      }
      for (const sigInfo of signatures) {
        const li = document.createElement("li");
        li.innerHTML = `<a href="https://explorer.solana.com/tx/${sigInfo.signature}?cluster=mainnet-beta" target="_blank">${sigInfo.signature.slice(0, 8)}...</a>`;
        txHistory.appendChild(li);
      }
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error loading history:`, err);
      if ((err.message.includes("Failed to fetch") || err.message.includes("401") || err.message.includes("403")) && i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      txHistory.innerHTML = `<li>History unavailable: ${err.message}. Configure your own RPC at https://www.quicknode.com.</li>`;
      return;
    }
  }
}

// Auto-update (disabled by default)
let intervalId = null;
function startAutoUpdate() {
  if (intervalId) clearInterval(intervalId);
  intervalId = setInterval(async () => {
    if (pubKey && connection) {
      await updateBalance();
      await loadTransactionHistory();
    }
  }, 60000);
}

function stopAutoUpdate() {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
  }
}

// Connect Wallet
connectBtn.addEventListener("click", async () => {
  provider = getProvider();
  if (!provider) return;

  try {
    const resp = await provider.connect();
    pubKey = new PublicKey(resp.publicKey.toString());
    walletAddress.textContent = `Wallet: ${pubKey.toBase58()}`;
    disconnectBtn.disabled = false;
    sendBtn.disabled = false;
    refreshBtn.disabled = false;

    if (!await updateConnection()) return;
    await updateBalance();
    await loadTransactionHistory();
    // Uncomment the line below to enable auto updates
    // startAutoUpdate();

    statusEl.textContent = "‚úÖ Connected to Mainnet Beta!";
  } catch (err) {
    console.error("Error connecting:", err);
    statusEl.textContent = `‚ùå Error connecting: ${err.message}`;
  }
});

// Disconnect Wallet
disconnectBtn.addEventListener("click", async () => {
  if (!provider) return;
  try {
    await provider.disconnect();
    pubKey = null;
    walletAddress.textContent = "Wallet: not connected";
    balanceEl.textContent = "-";
    statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
    txHistory.innerHTML = "";
    sendBtn.disabled = true;
    disconnectBtn.disabled = true;
    refreshBtn.disabled = true;
    stopAutoUpdate();
  } catch (err) {
    console.error("Error disconnecting:", err);
    statusEl.textContent = `‚ùå Error disconnecting: ${err.message}`;
  }
});

// Manual Refresh
refreshBtn.addEventListener("click", async () => {
  statusEl.textContent = "üîÑ Refreshing...";
  await updateBalance();
  await loadTransactionHistory();
  statusEl.textContent = pubKey ? "‚úÖ Refresh complete!" : "‚ö†Ô∏è Connect the wallet first.";
});

// Detect direct disconnect in Phantom
window.addEventListener("load", () => {
  provider = getProvider();
  if (provider) {
    provider.on("disconnect", () => {
      pubKey = null;
      walletAddress.textContent = "Wallet: not connected";
      balanceEl.textContent = "-";
      statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
      txHistory.innerHTML = "";
      sendBtn.disabled = true;
      disconnectBtn.disabled = true;
      refreshBtn.disabled = true;
      stopAutoUpdate();
    });
    if (provider.isConnected) {
      provider.connect().catch(() => {});
    }
  }
});

// Send SOL
sendBtn.addEventListener("click", async () => {
  if (!provider || !pubKey || !connection) {
    alert("Connect the wallet and check RPC connection!");
    return;
  }
  const destValue = destInput.value.trim();
  const amountValue = parseFloat(amountInput.value);

  if (!destValue || !amountValue || amountValue <= 0) {
    alert("Invalid address or amount.");
    return;
  }

  try {
    const toPubkey = new PublicKey(destValue);
    const lamports = Math.floor(amountValue * LAMPORTS_PER_SOL);

    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: pubKey,
        toPubkey: toPubkey,
        lamports: lamports
      })
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = pubKey;

    const { signature } = await provider.signAndSendTransaction(transaction);
    await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });

    statusEl.innerHTML = `‚úÖ Sent! Tx: <a href="https://explorer.solana.com/tx/${signature}?cluster=mainnet-beta" target="_blank">${signature.slice(0, 8)}...</a>`;

    await updateBalance();
    await loadTransactionHistory();
  } catch (err) {
    console.error("Error sending:", err);
    statusEl.textContent = `‚ùå Error sending: ${err.message}`;
  }
});
</script>
</body>
</html>
