<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solana Wallet Tools</title>
<meta name="description" content="Solana Wallet Tools" />
<meta name="author" content="Dev Twenty Seven" />
<link rel="icon" href="/assets/icons/27-mini-icon.png" type="image/png">

<style>
body { font-family: sans-serif; background:#111; color:#eee; padding:20px;}
input, button { margin:5px; padding:8px; font-size:14px; border-radius:5px;}
button { cursor:pointer; background:#512da8; color:white; border:none;}
button:disabled { background:#444; cursor:not-allowed;}
a { color:#4fc3f7; text-decoration:none;}
#status { word-wrap: break-word; }
#qrcode { margin-top:10px; }
</style>
</head>

<body>

<h1>Solana Mainnet Dashboard</h1>

<!-- Wallet Control Buttons -->
<button id="connectBtn">üîó Connect Wallet</button>
<button id="disconnectBtn" disabled>‚ùå Disconnect Wallet</button>
<button id="refreshBtn" disabled>üîÑ Refresh</button>

<p id="walletAddress">Wallet: not connected</p>

<!-- Copy and QR buttons -->
<button id="copyBtn" disabled>üìã Copy Address</button>
<button id="qrcodeBtn" disabled>üî≥ Generate QR Code</button>
<div id="qrcode"></div>

<h3>Balance:</h3>
<p id="balance">-</p>

<h3>Send SOL:</h3>
<label>Destination:</label>
<input type="text" id="destInput" placeholder="Base58 Address" size="60">
<label>Amount (SOL):</label>
<input type="number" id="amountInput" value="0.001" step="0.0001" min="0.0001">
<br>
<button id="sendBtn" disabled>üí∏ Send</button>

<h3>Recent Transactions:</h3>
<ul id="txHistory"></ul>

<p id="status">‚ÑπÔ∏è Connect your Phantom wallet to get started. For better performance, configure your own RPC at QuickNode or Ankr.</p>

<!-- Include QRCode library -->
<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

<script type="module">
import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "https://esm.sh/@solana/web3.js@1.95.3";

// ------------------------
// Variables and DOM elements
// ------------------------
let provider = null;
let pubKey = null;
let connection = null;
let currentRpcIndex = 0;
const RPC_ENDPOINTS = [
  "https://rpc.ankr.com/solana",
  "https://solana-rpc.publicnode.com",
  "https://api.mainnet-beta.solana.com"
];

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const refreshBtn = document.getElementById("refreshBtn");
const walletAddress = document.getElementById("walletAddress");
const balanceEl = document.getElementById("balance");
const statusEl = document.getElementById("status");
const destInput = document.getElementById("destInput");
const amountInput = document.getElementById("amountInput");
const txHistory = document.getElementById("txHistory");
const copyBtn = document.getElementById("copyBtn");
const qrcodeBtn = document.getElementById("qrcodeBtn");
const qrcodeDiv = document.getElementById("qrcode");

// ------------------------
// Helper functions
// ------------------------

// Sleep function for retry/backoff
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Connect to RPC with fallback
async function updateConnection() {
  for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
    try {
      connection = new Connection(RPC_ENDPOINTS[currentRpcIndex], "confirmed");
      console.log(`Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
      statusEl.textContent = `üîó Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`;
      return true;
    } catch (err) {
      console.error(`Failed to connect to RPC ${RPC_ENDPOINTS[currentRpcIndex]}:`, err);
      currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
    }
  }
  statusEl.textContent = "‚ùå Failed to connect to all RPCs. Configure your own RPC at QuickNode or Ankr.";
  return false;
}

// Detect Phantom wallet
const getProvider = () => {
  if ("solana" in window) {
    const provider = window.solana;
    if (provider.isPhantom) return provider;
  }
  alert("Phantom not found! Install the extension at https://phantom.app.");
  return null;
};

// ------------------------
// Balance & Transaction functions
// ------------------------

// Update wallet balance with retry/fallback
async function updateBalance(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    balanceEl.textContent = "Wallet or connection not available.";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const lamports = await connection.getBalance(pubKey);
      balanceEl.textContent = `${(lamports / LAMPORTS_PER_SOL).toFixed(4)} SOL (Mainnet Beta)`;
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error fetching balance:`, err);
      if (i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      balanceEl.textContent = `Error fetching balance: ${err.message}. Configure your own RPC at QuickNode.`;
      return;
    }
  }
}

// Load recent transactions with retry/fallback
async function loadTransactionHistory(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    txHistory.innerHTML = "<li>Wallet or connection not available.</li>";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const signatures = await connection.getSignaturesForAddress(pubKey, { limit: 10 });
      txHistory.innerHTML = "";
      if (signatures.length === 0) {
        txHistory.innerHTML = "<li>No recent transactions.</li>";
        return;
      }
      for (const sigInfo of signatures) {
        const li = document.createElement("li");
        li.innerHTML = `<a href="https://explorer.solana.com/tx/${sigInfo.signature}?cluster=mainnet-beta" target="_blank">${sigInfo.signature.slice(0, 8)}...</a>`;
        txHistory.appendChild(li);
      }
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error loading history:`, err);
      if (i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      txHistory.innerHTML = `<li>History unavailable: ${err.message}. Configure your own RPC at QuickNode.</li>`;
      return;
    }
  }
}

// ------------------------
// Wallet Actions
// ------------------------

// Connect wallet
connectBtn.addEventListener("click", async () => {
  provider = getProvider();
  if (!provider) return;

  try {
    const resp = await provider.connect();
    pubKey = new PublicKey(resp.publicKey.toString());
    walletAddress.textContent = `Wallet: ${pubKey.toBase58()}`;

    disconnectBtn.disabled = false;
    sendBtn.disabled = false;
    refreshBtn.disabled = false;
    copyBtn.disabled = false;
    qrcodeBtn.disabled = false;

    if (!await updateConnection()) return;
    await updateBalance();
    await loadTransactionHistory();

    statusEl.textContent = "‚úÖ Connected to Mainnet Beta!";
  } catch (err) {
    console.error("Error connecting:", err);
    statusEl.textContent = `‚ùå Error connecting: ${err.message}`;
  }
});

// Disconnect wallet
disconnectBtn.addEventListener("click", async () => {
  if (!provider) return;
  try {
    await provider.disconnect();
    pubKey = null;
    walletAddress.textContent = "Wallet: not connected";
    balanceEl.textContent = "-";
    statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
    txHistory.innerHTML = "";
    sendBtn.disabled = true;
    disconnectBtn.disabled = true;
    refreshBtn.disabled = true;
    copyBtn.disabled = true;
    qrcodeBtn.disabled = true;
    qrcodeDiv.innerHTML = "";
  } catch (err) {
    console.error("Error disconnecting:", err);
    statusEl.textContent = `‚ùå Error disconnecting: ${err.message}`;
  }
});

// Manual refresh
refreshBtn.addEventListener("click", async () => {
  statusEl.textContent = "üîÑ Refreshing...";
  await updateBalance();
  await loadTransactionHistory();
  statusEl.textContent = pubKey ? "‚úÖ Refresh complete!" : "‚ö†Ô∏è Connect the wallet first.";
});

// Copy wallet address to clipboard
copyBtn.addEventListener("click", () => {
  if (!pubKey) return;
  navigator.clipboard.writeText(pubKey.toBase58())
    .then(() => statusEl.textContent = "‚úÖ Wallet address copied to clipboard!")
    .catch(err => statusEl.textContent = `‚ùå Copy failed: ${err.message}`);
});

// Generate QR code for wallet address
qrcodeBtn.addEventListener("click", () => {
  if (!pubKey) return;
  qrcodeDiv.innerHTML = "";
  QRCode.toCanvas(pubKey.toBase58(), { width: 150 }, (err, canvas) => {
    if (err) {
      console.error(err);
      statusEl.textContent = `‚ùå QR code generation failed: ${err.message}`;
      return;
    }
    qrcodeDiv.appendChild(canvas);
    statusEl.textContent = "üî≥ QR code generated!";
  });
});

// Detect Phantom direct disconnect
window.addEventListener("load", () => {
  provider = getProvider();
  if (provider) {
    provider.on("disconnect", () => {
      pubKey = null;
      walletAddress.textContent = "Wallet: not connected";
      balanceEl.textContent = "-";
      statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
      txHistory.innerHTML = "";
      sendBtn.disabled = true;
      disconnectBtn.disabled = true;
      refreshBtn.disabled = true;
      copyBtn.disabled = true;
      qrcodeBtn.disabled = true;
      qrcodeDiv.innerHTML = "";
    });
    if (provider.isConnected) {
      provider.connect().catch(() => {});
    }
  }
});

// Send SOL
sendBtn.addEventListener("click", async () => {
  if (!provider || !pubKey || !connection) {
    alert("Connect the wallet and check RPC connection!");
    return;
  }
  const destValue = destInput.value.trim();
  const amountValue = parseFloat(amountInput.value);

  if (!destValue || !amountValue || amountValue <= 0) {
    alert("Invalid address or amount.");
    return;
  }

  try {
    const toPubkey = new PublicKey(destValue);
    const lamports = Math.floor(amountValue * LAMPORTS_PER_SOL);

    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: pubKey,
        toPubkey: toPubkey,
        lamports: lamports
      })
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = pubKey;

    const { signature } = await provider.signAndSendTransaction(transaction);
    await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });

    statusEl.innerHTML = `‚úÖ Sent! Tx: <a href="https://explorer.solana.com/tx/${signature}?cluster=mainnet-beta" target="_blank">${signature.slice(0, 8)}...</a>`;

    await updateBalance();
    await loadTransactionHistory();
  } catch (err) {
    console.error("Error sending:", err);
    statusEl.textContent = `‚ùå Error sending: ${err.message}`;
  }
});
</script>
</body>
</html>
