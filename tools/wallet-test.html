<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solana Wallet Tools</title>
<meta name="description" content="Solana Wallet Tools" />
<meta name="author" content="Dev Twenty Seven" />
<link rel="icon" href="/assets/icons/27-mini-icon.png" type="image/png">

<style>
body { font-family: sans-serif; background:#111; color:#eee; padding:20px;}
input, button { margin:5px; padding:8px; font-size:14px; border-radius:5px;}
button { cursor:pointer; background:#512da8; color:white; border:none;}
button:disabled { background:#444; cursor:not-allowed;}
a { color:#4fc3f7; text-decoration:none;}
#status { word-wrap: break-word; }
#qrcode { margin-top:10px; }

/* Tokens table styles */
#tokensBox { margin-top:20px; background:#222; padding:10px; border-radius:10px; max-height:420px; overflow:auto; }
.tokensTable { width:100%; border-collapse:collapse; }
.tokensTable th, .tokensTable td { padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.04); font-size:13px; vertical-align:middle;}
.tokensTable th { color:#bfc7d6; font-weight:600; font-size:12px; }
.tokenLogo { width:28px; height:28px; border-radius:6px; object-fit:cover; display:block; }
.col-right { text-align:right; } /* for value columns */
</style>
</head>

<body>

<h1>Solana Mainnet Dashboard</h1>

<!-- Wallet Control Buttons -->
<button id="connectBtn">üîó Connect Wallet</button>
<button id="disconnectBtn" disabled>‚ùå Disconnect Wallet</button>
<button id="refreshBtn" disabled>üîÑ Refresh</button>

<p id="walletAddress">Wallet: not connected</p>

<!-- Copy and QR buttons -->
<button id="copyBtn" disabled>üìã Copy Address</button>
<button id="qrcodeBtn" disabled>üî≥ Generate QR Code</button>
<div id="qrcode"></div>

<!-- SOL Price Display (above balance) -->
<h3 id="solPrice">SOL Price: - USD</h3>

<h3>Balance:</h3>
<p id="balance">-</p>

<h3>Send SOL:</h3>
<label>Destination:</label>
<input type="text" id="destInput" placeholder="Base58 Address" size="60">
<label>Amount (SOL):</label>
<input type="number" id="amountInput" value="0.001" step="0.0001" min="0.0001">
<br>
<button id="sendBtn" disabled>üí∏ Send</button>

<h3>Recent Transactions:</h3>
<ul id="txHistory"></ul>

<!-- Token list box -->
<h3>Tokens:</h3>
<div id="tokensBox">No tokens detected.</div>

<p id="status">‚ÑπÔ∏è Connect your Phantom wallet to get started. For better performance, configure your own RPC at QuickNode or Ankr.</p>

<!-- Include QRCode library -->
<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

<script type="module">
/*
  Solana Wallet Tools - wallet-test.html
  - Adds token table using on-chain parsed token accounts
  - Enriches token info via DexScreener (logo, symbol, name, price)
  - Shows Value in SOL and USD (N/A when not available)
  - SOL price from CoinGecko (used to compute value in SOL when only USD price exists)
  - All UI text and comments in English
*/

import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "https://esm.sh/@solana/web3.js@1.95.3";
import { TOKEN_PROGRAM_ID } from "https://esm.sh/@solana/spl-token@0.2.0";

// ------------------------
// Variables and DOM elements
// ------------------------
let provider = null;
let pubKey = null;
let connection = null;
let currentRpcIndex = 0;
let solPriceUSD = 0;
const RPC_ENDPOINTS = [
  "https://rpc.ankr.com/solana",
  "https://solana-rpc.publicnode.com",
  "https://api.mainnet-beta.solana.com"
];

const connectBtn = document.getElementById("connectBtn");
const disconnectBtn = document.getElementById("disconnectBtn");
const refreshBtn = document.getElementById("refreshBtn");
const walletAddress = document.getElementById("walletAddress");
const balanceEl = document.getElementById("balance");
const solPriceEl = document.getElementById("solPrice");
const statusEl = document.getElementById("status");
const destInput = document.getElementById("destInput");
const amountInput = document.getElementById("amountInput");
const txHistory = document.getElementById("txHistory");
const copyBtn = document.getElementById("copyBtn");
const qrcodeBtn = document.getElementById("qrcodeBtn");
const qrcodeDiv = document.getElementById("qrcode");
const tokensBox = document.getElementById("tokensBox");
const sendBtn = document.getElementById("sendBtn");

// ------------------------
// Helper functions
// ------------------------

// Sleep for backoff between API calls (used to avoid rate limits)
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Connect to RPC with fallback
async function updateConnection() {
  for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
    try {
      connection = new Connection(RPC_ENDPOINTS[currentRpcIndex], "confirmed");
      console.log(`Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
      statusEl.textContent = `üîó Connected to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`;
      return true;
    } catch (err) {
      console.error(`Failed to connect to RPC ${RPC_ENDPOINTS[currentRpcIndex]}:`, err);
      currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
    }
  }
  statusEl.textContent = "‚ùå Failed to connect to all RPCs. Configure your own RPC at QuickNode or Ankr.";
  return false;
}

// Detect Phantom wallet
const getProvider = () => {
  if ("solana" in window) {
    const provider = window.solana;
    if (provider.isPhantom) return provider;
  }
  alert("Phantom not found! Install the extension at https://phantom.app.");
  return null;
};

// ------------------------
// Price & Balance functions
// ------------------------

// Fetch SOL price (USD) from CoinGecko
async function fetchSolPrice() {
  try {
    const res = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd");
    const data = await res.json();
    solPriceUSD = (data && data.solana && data.solana.usd) ? data.solana.usd : 0;
    solPriceEl.textContent = solPriceUSD ? `SOL Price: $${solPriceUSD.toFixed(2)} USD` : "SOL Price: unavailable";
  } catch (err) {
    console.error("Error fetching SOL price:", err);
    solPriceEl.textContent = "SOL Price: unavailable";
  }
}

// Update wallet balance with retry/fallback
async function updateBalance(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    balanceEl.textContent = "Wallet or connection not available.";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const lamports = await connection.getBalance(pubKey);
      balanceEl.textContent = `${(lamports / LAMPORTS_PER_SOL).toFixed(4)} SOL (Mainnet Beta)`;
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error fetching balance:`, err);
      if (i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      balanceEl.textContent = `Error fetching balance: ${err.message}. Configure your own RPC at QuickNode.`;
      return;
    }
  }
}

// ------------------------
// Transaction History
// ------------------------
async function loadTransactionHistory(attempts = 3, delay = 2000) {
  if (!pubKey || !connection) {
    txHistory.innerHTML = "<li>Wallet or connection not available.</li>";
    return;
  }
  for (let i = 0; i < attempts; i++) {
    try {
      const signatures = await connection.getSignaturesForAddress(pubKey, { limit: 10 });
      txHistory.innerHTML = "";
      if (signatures.length === 0) {
        txHistory.innerHTML = "<li>No recent transactions.</li>";
        return;
      }
      for (const sigInfo of signatures) {
        const li = document.createElement("li");
        li.innerHTML = `<a href="https://explorer.solana.com/tx/${sigInfo.signature}?cluster=mainnet-beta" target="_blank">${sigInfo.signature.slice(0,8)}...</a>`;
        txHistory.appendChild(li);
      }
      return;
    } catch (err) {
      console.error(`Attempt ${i + 1} - Error loading history:`, err);
      if (i < attempts - 1) {
        currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
        await updateConnection();
        await sleep(delay * (i + 1));
        continue;
      }
      txHistory.innerHTML = `<li>History unavailable: ${err.message}. Configure your own RPC at QuickNode.</li>`;
      return;
    }
  }
}

// ------------------------
// Tokens List using DexScreener (fallback to N/A)
// - Only tokens with amount > 0 will be shown
// - Attempts to retrieve logo, symbol, name, and price via DexScreener
// - If price available: compute Value (USD) and Value (SOL). Otherwise show "N/A"
// ------------------------
async function loadTokens() {
  if (!pubKey || !connection) return;
  tokensBox.innerHTML = "Loading tokens...";

  try {
    // Get parsed token accounts owned by wallet
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubKey, { programId: TOKEN_PROGRAM_ID });

    // Prepare table
    const table = document.createElement("table");
    table.className = "tokensTable";
    const header = document.createElement("thead");
    header.innerHTML = `
      <tr>
        <th>Logo</th>
        <th>Symbol</th>
        <th>Name</th>
        <th>Amount</th>
        <th class="col-right">Value (SOL)</th>
        <th class="col-right">Value (USD)</th>
      </tr>`;
    table.appendChild(header);
    const tbody = document.createElement("tbody");

    let displayed = 0;

    // Iterate token accounts and show only those with positive balance
    for (const { account } of tokenAccounts.value) {
      const uiAmount = account.data.parsed.info.tokenAmount.uiAmount;
      if (!uiAmount || uiAmount === 0) continue; // Skip zero balances

      const mintAddress = account.data.parsed.info.mint;
      const amount = uiAmount;

      // Default placeholders
      let logoURI = "https://via.placeholder.com/28?text=?";
      let symbol = mintAddress.slice(0, 6);
      let name = "Unknown Token";
      let priceUsd = null;      // Price in USD per token
      let priceNative = null;   // Price in native unit (e.g., SOL) per token (if provided)

      // Try fetch from DexScreener. Rate-limit-friendly: small delay between requests.
      try {
        // DexScreener token endpoint (may return many pairs). We try to parse the first valid pair.
        const dexRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mintAddress}`);
        if (dexRes.ok) {
          const dexData = await dexRes.json();
          // dexData.pairs is an array of markets. Choose first pair that has baseToken info.
          const pair = (dexData && Array.isArray(dexData.pairs) && dexData.pairs.length > 0) ? dexData.pairs[0] : null;
          if (pair) {
            // pair.baseToken usually holds token metadata on DexScreener responses
            const base = pair.baseToken || {};
            symbol = base.symbol || symbol;
            name = base.name || name;
            // DexScreener does not provide logoURI; try to fetch from token list or leave as placeholder
            // For now, we keep the placeholder as DexScreener doesn't provide a logo

            // DexScreener pair may include priceUsd or priceNative fields
            // Try to read priceUsd or price or priceNative. Parse to float if present.
            if (pair.priceUsd) priceUsd = parseFloat(pair.priceUsd);
            if (!priceUsd && pair.price) priceUsd = parseFloat(pair.price); // Fallback
            if (pair.priceNative) priceNative = parseFloat(pair.priceNative);
            // Note: priceNative may represent price in native chain token (SOL) depending on pair.
          }
        } else {
          console.warn(`DexScreener returned ${dexRes.status} for ${mintAddress}`);
        }
      } catch (err) {
        console.warn(`DexScreener lookup failed for ${mintAddress}:`, err);
      }

      // Try to fetch logo from Solana token list as a fallback
      try {
        const tokenListRes = await fetch("https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json");
        if (tokenListRes.ok) {
          const tokenList = await tokenListRes.json();
          const token = tokenList.tokens.find(t => t.address === mintAddress);
          if (token && token.logoURI) {
            logoURI = token.logoURI;
          }
        }
      } catch (err) {
        console.warn(`Failed to fetch token list for logo of ${mintAddress}:`, err);
      }

      // Compute values
      let valueUSD = null;
      let valueSOL = null;

      if (priceUsd && !isNaN(priceUsd)) {
        valueUSD = amount * priceUsd;
        if (solPriceUSD && solPriceUSD > 0) {
          valueSOL = valueUSD / solPriceUSD;
        } else if (priceNative && !isNaN(priceNative)) {
          // If dex provided native price (likely in SOL), prefer that
          valueSOL = amount * priceNative;
        }
      } else if (priceNative && !isNaN(priceNative)) {
        // priceNative present but priceUsd not: priceNative likely quoted in SOL
        valueSOL = amount * priceNative;
        if (solPriceUSD && solPriceUSD > 0) {
          valueUSD = valueSOL * solPriceUSD;
        }
      }

      const tr = document.createElement("tr");
      const tdLogo = document.createElement("td");
      const img = document.createElement("img");
      img.src = logoURI;
      img.className = "tokenLogo";
      img.alt = symbol;
      img.onerror = () => {
        img.src = "https://via.placeholder.com/28?text=?"; // Fallback if image fails to load
      };
      tdLogo.appendChild(img);

      const tdSymbol = document.createElement("td");
      tdSymbol.textContent = symbol;

      const tdName = document.createElement("td");
      tdName.textContent = name;

      const tdAmount = document.createElement("td");
      tdAmount.textContent = Number(amount).toLocaleString(undefined, {maximumFractionDigits: 6});

      const tdValueSOL = document.createElement("td");
      tdValueSOL.className = "col-right";
      tdValueSOL.textContent = valueSOL != null ? Number(valueSOL).toLocaleString(undefined, {maximumFractionDigits:6}) : "N/A";

      const tdValueUSD = document.createElement("td");
      tdValueUSD.className = "col-right";
      tdValueUSD.textContent = valueUSD != null ? `$${Number(valueUSD).toLocaleString(undefined, {maximumFractionDigits:2})}` : "N/A";

      tr.appendChild(tdLogo);
      tr.appendChild(tdSymbol);
      tr.appendChild(tdName);
      tr.appendChild(tdAmount);
      tr.appendChild(tdValueSOL);
      tr.appendChild(tdValueUSD);

      tbody.appendChild(tr);

      displayed++;
      // Small delay to be polite to DexScreener / avoid bursts
      await sleep(150);
    }

    if (displayed === 0) {
      tokensBox.innerHTML = "No tokens with balance > 0";
      return;
    }

    table.appendChild(tbody);
    tokensBox.innerHTML = "";
    tokensBox.appendChild(table);

  } catch (err) {
    console.error("Error loading tokens:", err);
    tokensBox.innerHTML = `Error loading tokens: ${err.message}`;
  }
}

// ------------------------
// Wallet Actions
// ------------------------

// Connect wallet
connectBtn.addEventListener("click", async () => {
  provider = getProvider();
  if (!provider) return;

  try {
    const resp = await provider.connect();
    pubKey = new PublicKey(resp.publicKey.toString());
    walletAddress.textContent = `Wallet: ${pubKey.toBase58()}`;

    disconnectBtn.disabled = false;
    sendBtn.disabled = false;
    refreshBtn.disabled = false;
    copyBtn.disabled = false;
    qrcodeBtn.disabled = false;

    // Fetch SOL price first (used by token value calculations)
    await fetchSolPrice();

    if (!await updateConnection()) return;
    await updateBalance();
    await loadTransactionHistory();
    await loadTokens();

    statusEl.textContent = "‚úÖ Connected to Mainnet Beta!";
  } catch (err) {
    console.error("Error connecting:", err);
    statusEl.textContent = `‚ùå Error connecting: ${err.message}`;
  }
});

// Disconnect wallet
disconnectBtn.addEventListener("click", async () => {
  if (!provider) return;
  try {
    await provider.disconnect();
    pubKey = null;
    walletAddress.textContent = "Wallet: not connected";
    balanceEl.textContent = "-";
    solPriceEl.textContent = "SOL Price: - USD";
    statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
    txHistory.innerHTML = "";
    tokensBox.innerHTML = "No tokens detected.";
    sendBtn.disabled = true;
    disconnectBtn.disabled = true;
    refreshBtn.disabled = true;
    copyBtn.disabled = true;
    qrcodeBtn.disabled = true;
    qrcodeDiv.innerHTML = "";
  } catch (err) {
    console.error("Error disconnecting:", err);
    statusEl.textContent = `‚ùå Error disconnecting: ${err.message}`;
  }
});

// Manual refresh
refreshBtn.addEventListener("click", async () => {
  statusEl.textContent = "üîÑ Refreshing...";
  await fetchSolPrice();
  await updateBalance();
  await loadTransactionHistory();
  await loadTokens();
  statusEl.textContent = pubKey ? "‚úÖ Refresh complete!" : "‚ö†Ô∏è Connect the wallet first.";
});

// Copy wallet address to clipboard
copyBtn.addEventListener("click", () => {
  if (!pubKey) return;
  navigator.clipboard.writeText(pubKey.toBase58())
    .then(() => statusEl.textContent = "‚úÖ Wallet address copied to clipboard!")
    .catch(err => statusEl.textContent = `‚ùå Copy failed: ${err.message}`);
});

// Generate QR code for wallet address
qrcodeBtn.addEventListener("click", () => {
  if (!pubKey) return;
  qrcodeDiv.innerHTML = "";
  QRCode.toCanvas(pubKey.toBase58(), { width: 150 }, (err, canvas) => {
    if (err) {
      console.error(err);
      statusEl.textContent = `‚ùå QR code generation failed: ${err.message}`;
      return;
    }
    qrcodeDiv.appendChild(canvas);
    statusEl.textContent = "üî≥ QR code generated!";
  });
});

// Detect Phantom direct disconnect
window.addEventListener("load", () => {
  provider = getProvider();
  if (provider) {
    provider.on("disconnect", () => {
      pubKey = null;
      walletAddress.textContent = "Wallet: not connected";
      balanceEl.textContent = "-";
      solPriceEl.textContent = "SOL Price: - USD";
      statusEl.textContent = "‚ö†Ô∏è Wallet disconnected";
      txHistory.innerHTML = "";
      tokensBox.innerHTML = "No tokens detected.";
      sendBtn.disabled = true;
      disconnectBtn.disabled = true;
      refreshBtn.disabled = true;
      copyBtn.disabled = true;
      qrcodeBtn.disabled = true;
      qrcodeDiv.innerHTML = "";
    });
    if (provider.isConnected) {
      // Attempt to re-connect silently
      provider.connect().catch(() => {});
    }
  }
});

// ------------------------
// Send SOL
// ------------------------
sendBtn.addEventListener("click", async () => {
  if (!provider || !pubKey || !connection) {
    alert("Connect the wallet and check RPC connection!");
    return;
  }
  const destValue = destInput.value.trim();
  const amountValue = parseFloat(amountInput.value);

  if (!destValue || !amountValue || amountValue <= 0) {
    alert("Invalid address or amount.");
    return;
  }

  try {
    const toPubkey = new PublicKey(destValue);
    const lamports = Math.floor(amountValue * LAMPORTS_PER_SOL);

    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: pubKey,
        toPubkey: toPubkey,
        lamports: lamports
      })
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = pubKey;

    // Use provider.signAndSendTransaction (Phantom)
    const { signature } = await provider.signAndSendTransaction(transaction);
    await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });

    statusEl.innerHTML = `‚úÖ Sent! Tx: <a href="https://explorer.solana.com/tx/${signature}?cluster=mainnet-beta" target="_blank">${signature.slice(0, 8)}...</a>`;

    await updateBalance();
    await loadTransactionHistory();
    await loadTokens();
  } catch (err) {
    console.error("Error sending:", err);
    statusEl.textContent = `‚ùå Error sending: ${err.message}`;
  }
});
</script>
</body>
</html>
